---
layout: post
title:  "Threads"
date:   2017-05-06 00:00:00 +0000
categories: [General]
tags: [thread, process, thread-pool]
---


A `process` is a collection of virtual memory space, code, data, and system resources.  
A `thread` is code that is to be serially executed within a process.  
A processor executes threads, not processes, so each application has at least one process, and a process always has at least one thread of execution, known as the primary thread. 

Processes communicate with one another through messages, using Microsoft's Remote Procedure Call (RPC) technology to pass information to one another. 

When a thread begins to execute, it continues until it is killed or until it is interrupted by a thread with higher priority. Each thread can run separate sections of code, or multiple threads can execute the same section of code. Threads executing the same block of code maintain separate stacks. Each thread in a process shares that process's global variables and resources.

The thread scheduler determines when and how often to execute a thread, according to a combination of the process's priority class attribute and the thread's base priority. 

The `ThreadPool` class provides your application with a pool of worker threads that are managed by the system. 

> Beginning with the .NET Framework 4 you can create `Task` and `Task<TResult>` objects, which perform asynchronous tasks on thread pool threads. 

The .NET Framework uses thread pool threads for many purposes, including asynchronous I/O completion, timer callbacks, registered wait operations, asynchronous method calls using delegates, and System.Net socket connections.


### When Not to Use Thread Pool Threads 
There are several scenarios in which it is appropriate to create and manage your own threads instead of using thread pool threads

 * You require a foreground thread.
   - Background threads are identical to foreground threads with one exception: a background thread does not keep the managed execution environment running. ***The application won't wait until the background threads are completed***, but it will wait until all the foreground threads are terminated. Once all foreground threads have been stopped in a managed process (where the .exe file is a managed assembly), the system stops all background threads and shuts down.
   - Threads that belong to the managed thread pool (that is, threads whose IsThreadPoolThread property is true) are background threads. 
   - All threads that enter the managed execution environment from unmanaged code are marked as background threads.
   - All threads generated by creating and starting a new Thread object are by default foreground threads.
   - A thread can be changed to a background thread at any time by setting its IsBackground property to true. 
   - If you use a thread to monitor an activity, such as a socket connection, set its IsBackground property to true so that the thread does not prevent your process from terminating. Background threads can be useful for polling services or logging services which could be discontinued once the application is closed. 
 * You require a thread to have a particular priority. 
 * You have tasks that cause the thread to block for long periods of time. The thread pool has a maximum number of threads, so a large number of blocked thread pool threads might prevent tasks from starting.
   - There is one thread pool per process. 
   - Beginning with the .NET 4, the default size of the thread pool for a process depends on bitness and OS resources such as the size of the virtual address space. A process can call the `GetMaxThreads` method to determine the number of threads at runtime. 
   - Each thread uses the default stack size (4MB for 64-nit and 1MB for 32-bit code) and runs at the default priority.
   - The ideal for a TP thread is to not take more than half a second.

Beginning with the .NET Framework 4, the easiest way to use the thread pool is to use the Task Parallel Library (TPL).

How many threads are there in this HelloWorld app when Console.ReadLine() line is reached, and what state are they in, e.g. Running, Suspended, etc. ?

```csharp
static void Main(string[] args) 
{
    Console.WriteLine("Hello world");
    Console.ReadLine();
}
```

There's no definite number. This code is only running on one thread - the main thread. Calling Console.ReadLine doesn't create a new thread, it just starts an I/O request and waits for it to be processed - this requires no threads, but since you're using the synchronous API, there's no way to release your thread, so it just blocks. 

There's a lot of infrastructure threads - the Garbage Collector and Finalizer threads are the main ones, and some of those are created and destroyed all the time. 

Finally, there's the threads somewhere in between - most notably, the thread pool. Since you're not using the thread-pool, it will have the default number of threads (unless the configuration says otherwise), this is usually one thread per logical CPU core. 

 > Logical cores are the number of physical cores times the number of threads that can run on each core through the use of hyperthreading. for example, my 4-core processor runs two threads per core, so I have 8 logical processors. 


Simplest way to get to all Managed Threads is to install NuGet package CLR Memory Diagnostics (ClrMD).
using Microsoft.Diagnostics.Runtime;

```csharp
using (DataTarget target = DataTarget.AttachToProcess(
    Process.GetCurrentProcess().Id, 5000, AttachFlag.Passive))
{
  ClrRuntime runtime = target.ClrVersions.First().CreateRuntime();


  Console.WriteLine(
    string.Format("{0,15} {1,15} {2,15} {3,15} {4,15} {5,15} {6,15} {7,15} {8,15} {9,15} {10,15} {11,15}", 
                "OSThreadId", "IsAlive", "IsBackground", "IsFinalizer", "IsGC", "IsMTA", 
                "IsSTA", "IsTPCompletionPort", "IsTPGate", "IsTPTimer", "IsTPWait", "IsTPWorker"));


  foreach (ClrThread thread in runtime.Threads)
  {
    Console.WriteLine(
        string.Format("{0,15} {1,15} {2,15} {3,15} {4,15} {5,15} {6,15} {7,15} {8,15} {9,15} {10,15} {11,15}",  
        t.OSThreadId, t.IsAlive, t.IsBackground, t.IsFinalizer, t.IsGC, t.IsMTA, t.IsSTA, 
        t.IsThreadpoolCompletionPort, t.IsThreadpoolGate, t.IsThreadpoolTimer, 
        t.IsThreadpoolWait, t.IsThreadpoolWorker));
    }
}

  //This will return OS Threads. 
  Process.GetCurrentProcess().Threads; 
  
  In my case in Console app, it returns:
  // 2 managed (Main and Finalizer)
  //   * Main is in 'Runing' state with Normal priority, 
  //   * Finalizer is background thread in 'Wait' state with Highest priority, 
  // 4 unamaged (I assume thread pool threads, ONE for each processor core? 
  //   I expected 8 because ThreadPool.GetMinThreads)
  
  In WinForms app, it returns:
  // 2 managed (Main and Finalizer)
  //   * Main is in 'Runing' state with Normal priority, unilike Console app 
  //     Main thread is STA (single   threaded apartment)
  //   * Finalizer is background thread in 'Wait' state with Highest priority, 
  // 8 unamaged (I assume thread pool threads, two for each processor core, 
  //   this is expected, matches the  number I get from ThreadPool.GetMinThreads)
```
